function [ SeriesEval ] = EvalSeries( EvalPoints,SampleSeriesCoeff,truncvec,Proldat,L )

% This function evaluates the sampling series on a given array of points
%
%   Input - EvalPoints: Evaluation points in cartesian form x|y|z
%           SampleSeriesCoeff : Cell array of coefficients generated by
%                               ConstructSeriesCoeff.mat
%           truncvec : Number of radial GPSWFs that correspond to each value
%                      of N between 0 and Nmax generated by
%                      ConstructSeriesCoeff.mat
%           Proldat :  Data array for radial GPSWFs evaluation (generated by
%                      Lederman's code generated by ConstructSeriesCoeff.mat
%           L : Sampling parameter.
%
%   Output - SeriesEval : Vector of evaluations of the partial sum on 
%                         the evaluation points

%%%%%%%%%%%%%%%% Part1 - Transform points into polar coordinates %%%%%%%%%%%%%%%%%%%%%%
[azimuth,elevation,radius] = cart2sph(EvalPoints(:,1),EvalPoints(:,2),EvalPoints(:,3));
EvalPointsPolar = horzcat(azimuth,elevation,radius);
EvalPointsPolar(:,2) = (-1)*EvalPointsPolar(:,2)+pi/2;

%%%%%%%%%%%%%%%% Part2 - Evaluate the sampling series %%%%%%%%%%%%%%%%%%%%%%
SeriesEval = zeros(1,length(EvalPoints(:,1)));
Nmax = length(truncvec) - 1;
position = 1;

for j= 1:Nmax+1
    
    [EvalTemp,alphavect] = EvalProlGrid_fixedN(EvalPointsPolar,j-1,Proldat{1,j},Proldat{2,j},Proldat{3,j},truncvec(1,j),1,L);
    positionend = length(EvalTemp(:,1))+position-1;
    SeriesEval = SeriesEval+sum(EvalTemp.*repmat(SampleSeriesCoeff(position:positionend,1),1,length(EvalPoints(:,1))),1);
    position = positionend+1;
    
end


end

